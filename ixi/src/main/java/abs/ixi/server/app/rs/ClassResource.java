package abs.ixi.server.app.rs;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.LinkedHashMap;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import abs.ixi.server.app.ApplicationInitializationError;
import abs.ixi.server.app.RequestContext;
import abs.ixi.server.app.XmppRequest;
import abs.ixi.server.app.XmppResponse;

/**
 * {@code ClassResource} is generated by introspecting a class using Java
 * Reflection. It hold method info, method annotations and class level
 * annotation.
 */
public final class ClassResource<T> {
	private static final Logger LOGGER = LoggerFactory.getLogger(ClassResource.class);
	
	private static final String SLASH = "/";

	private T receiver;
	private Class<T> clz;
	private String[] uriSegments;
	private Map<String, ResourceOperation> operations;

	@SuppressWarnings("unchecked")
	public ClassResource(T receiver) throws ApplicationInitializationError{
		this.receiver = receiver;
		this.clz = (Class<T>) receiver.getClass();
		this.uriSegments = findUriSegment(clz);
		this.operations = findOperations(clz);
	}

	/**
	 * Invokes method matching the uriSegment on the object given
	 * 
	 * @param obj
	 * @param request
	 * @param ctx
	 * @return
	 * @throws InvocationTargetException
	 */
	public XmppResponse invokeOperation(XmppRequest request, RequestContext ctx, Endpoint ep) throws InvocationTargetException {
		ResourceOperation op = this.operations.get(ep.unmatchedSegment());

		if (op == null) {
			throw new RuntimeException("No operation matched urisegment: " + ctx.getUri());
		}

		try {
			return op.invoke(receiver, request, ctx, ep);

		} catch (IllegalAccessException e) {
			LOGGER.error("Method invocation failed due to less access", e);
			throw new RuntimeException("Method invocation failed due to less access");

		} catch (IllegalArgumentException e) {
			LOGGER.error("Incorrect argument supplied for method invocation", e);
			throw new RuntimeException("Incorrect argument supplied for method invocation");

		} catch (InvocationTargetException e) {
			throw e;
		}
	}

	public Class<T> getResourceClass() {
		return clz;
	}

	@SuppressWarnings("rawtypes")
	@Override
	public boolean equals(Object obj) {
		if (obj == null) {
			return false;
		}

		if (this == obj) {
			return true;
		}

		if (this.clz == obj.getClass()) {
			if (this.operations.size() == ((ClassResource) obj).getOperations().size()) {
				return true;
			}
		}

		return false;
	}

	public String[] findUriSegment(Class<T> clz) {
		assert clz != null : "Class can not be null to genearte class resource";

		URISegment uriseg = clz.getAnnotation(URISegment.class);
		return uriseg != null ? new String[] { uriseg.value() } : null;
	}

	public Map<String, ResourceOperation> findOperations(Class<T> clz) {
		assert clz != null : "Class can not be null to genearte class resource";

		Map<String, ResourceOperation> operations = new LinkedHashMap<>();
		Method[] methods = clz.getDeclaredMethods();

		for (Method m : methods) {
			URISegment uriseg = m.getAnnotation(URISegment.class);

			if (uriseg != null) {
				operations.put(uriseg.value().split(SLASH)[0], new ResourceOperation(m, uriseg.value()));
			}
		}

		return operations;
	}

	public Map<String, ResourceOperation> getOperations() {
		return this.operations;
	}

	public String[] getUriSegments() {
		return this.uriSegments;
	}

	public void setUriSegments(String[] uriSegments) {
		this.uriSegments = uriSegments;
	}

}
